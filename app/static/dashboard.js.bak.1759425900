// Worker Analytics Dashboard — v9 (writeoff + inflow in metrics, multi-warehouse)

function fmt(x){return (x??0).toLocaleString('ru-RU',{minimumFractionDigits:2, maximumFractionDigits:2});}
function pctDelta(a,b){ if(!isFinite(a)||!isFinite(b)||b===0) return NaN; return (a/b*100-100); }
function cls(n){ return isFinite(n) ? (n>=0?'good':'bad') : ''; }
function toISO(d){ const z=new Date(d); z.setHours(0,0,0,0); return `${z.getFullYear()}-${String(z.getMonth()+1).padStart(2,'0')}-${String(z.getDate()).padStart(2,'0')}`; }
const parseISO=(s)=>{ const [y,m,dd]=s.split('-').map(Number); const d=new Date(y, m-1, dd); d.setHours(0,0,0,0); return d; };
function lastDayOfMonth(y,m){ return new Date(y, m+1, 0); }
function debounced(fn,ms=250){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
async function jget(url){ const r=await fetch(url,{credentials:'include'}); if(!r.ok) throw new Error(url+' -> '+r.status); return r.json(); }
function by(arr,key){ const m={}; for(const r of arr){ const k=r[key]; (m[k] ||= []).push(r); } return m; }

function setPeriodCurrentMonth(){
  const now=new Date();
  const start=new Date(now.getFullYear(), now.getMonth(), 1);
  const end=lastDayOfMonth(now.getFullYear(), now.getMonth());
  start.setHours(0,0,0,0); end.setHours(0,0,0,0);
  document.getElementById('start').value=toISO(start);
  document.getElementById('end').value=toISO(end);
}
function setPeriodPrevMonth(){
  const now=new Date();
  const prevFirst=new Date(now.getFullYear(), now.getMonth()-1, 1);
  const prevLast=lastDayOfMonth(prevFirst.getFullYear(), prevFirst.getMonth());
  prevFirst.setHours(0,0,0,0); prevLast.setHours(0,0,0,0);
  document.getElementById('start').value=toISO(prevFirst);
  document.getElementById('end').value=toISO(prevLast);
}
function setPeriodYTD(){ // до вчера
  const now=new Date();
  const start=new Date(now.getFullYear(),0,1);
  const end=new Date(now); end.setDate(end.getDate()-1);
  start.setHours(0,0,0,0); end.setHours(0,0,0,0);
  document.getElementById('start').value=toISO(start);
  document.getElementById('end').value=toISO(end);
}
function setPeriodPrevYear(){
  const y=(new Date()).getFullYear()-1;
  const start=new Date(y,0,1), end=new Date(y,11,31);
  start.setHours(0,0,0,0); end.setHours(0,0,0,0);
  document.getElementById('start').value=toISO(start);
  document.getElementById('end').value=toISO(end);
}

function rangeDays(startISO,endISO){
  const s=parseISO(startISO), e=parseISO(endISO);
  const days=[]; let d=new Date(s);
  while(d<=e){ days.push(toISO(d)); d.setDate(d.getDate()+1); }
  return days;
}
function prevPeriodRange(startISO,endISO){
  const len=rangeDays(startISO,endISO).length;
  const s=parseISO(startISO);
  const prevEnd=new Date(s); prevEnd.setDate(prevEnd.getDate()-1);
  const prevStart=new Date(prevEnd); prevStart.setDate(prevStart.getDate()-(len-1));
  return {start:toISO(prevStart),end:toISO(prevEnd)};
}
function prevYearRange(startISO,endISO){
  const s=parseISO(startISO), e=parseISO(endISO);
  const s2=new Date(s.getFullYear()-1,s.getMonth(),s.getDate());
  const e2=new Date(e.getFullYear()-1,e.getMonth(),e.getDate());
  s2.setHours(0,0,0,0); e2.setHours(0,0,0,0);
  return {start:toISO(s2),end:toISO(e2)};
}

window.__WAREHOUSES__=[];
function getSelectedWarehouseIds(){
  // Читаем все чекбоксы с name="wh[]"
  const boxes=document.querySelectorAll('input[name="wh[]"]:checked');
  const ids=[...boxes].map(b=>b.value);
  // если ни одного не выбрано — трактуем как «все»
  if(ids.length===0) return (window.__WAREHOUSES__||[]).map(w=>String(w.id));
  return ids;
}
function findWarehouseNameById(id){
  const w=(window.__WAREHOUSES__||[]).find(x=>String(x.id)===String(id));
  return w?.name;
}

async function loadWarehouses(){
  try{
    const res=await jget('/api/warehouses'); window.__WAREHOUSES__=res.data||[];
    // Рисуем панель мультивыбора, если её нет
    if(!document.getElementById('wh-multi')){
      const grid=document.querySelector('.grid'); if(!grid) return;
      const card=document.createElement('div'); card.className='card col-12'; card.id='wh-multi';
      let html='<div class="muted">Склады:</div><div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:8px">';
      for(const w of window.__WAREHOUSES__){
        html+=`<label style="user-select:none"><input type="checkbox" name="wh[]" value="${w.id}"> ${w.name}</label>`;
      }
      html+='</div>';
      card.innerHTML=html;
      grid.insertBefore(card, grid.firstChild);
      card.addEventListener('change', debounced(()=>loadComparison()));
    }
  }catch(e){ console.error('warehouses load failed', e); }
}

async function loadChartsAndKPI(){
  const [rev, mar, inf] = await Promise.all([
    jget('/api/revenue/daily?days=60'),
    jget('/api/margin/daily?days=60'),
    jget('/api/inflow/daily?days=60'),
  ]);
  const revRows = rev.data||[], marRows = mar.data||[], infRows = inf.data||[];

  const from7 = (()=>{const d=new Date(); d.setDate(d.getDate()-6); d.setHours(0,0,0,0); return toISO(d);})();
  const kRows = marRows.filter(r=>r.date>=from7);
  const kRev = kRows.reduce((s,r)=>s+(r.revenue||0),0);
  const kGP  = kRows.reduce((s,r)=>s+(r.gross_profit||0),0);
  const kChecks = (revRows.filter(r=>r.date>=from7)).reduce((s,r)=>s+(r.receipts||0),0);
  const kMargin = kRev ? (kGP/kRev*100) : 0;
  const kAT = kChecks ? (kRev/kChecks) : 0;
  const set=(id,txt)=>{ const el=document.getElementById(id); if(el) el.textContent=txt; };
  set('kpi-rev', fmt(kRev)+' ₽'); set('kpi-gp', fmt(kGP)+' ₽'); set('kpi-margin', kMargin.toFixed(1)+' %'); set('kpi-at', fmt(kAT)+' ₽');

  if(window.Plotly){
    const byWh = by(revRows,'warehouse'); const dates=[...new Set(revRows.map(r=>r.date))].sort();
    Plotly.newPlot('chart-revenue',
      Object.entries(byWh).map(([wh, arr])=>{
        const map=Object.fromEntries(arr.map(r=>[r.date,r.revenue]));
        return {x:dates,y:dates.map(d=>map[d]??0),type:'scatter',mode:'lines+markers',name:wh};
      }),
      {paper_bgcolor:'#0b0c10',plot_bgcolor:'#0b0c10',xaxis:{gridcolor:'#222831',tickformat:'%Y-%m-%d'},yaxis:{gridcolor:'#222831',title:'₽'},margin:{t:10,r:10,b:40,l:60}},
      {displayModeBar:false,responsive:true}
    );

    const byWhM = by(marRows,'warehouse'); const datesM=[...new Set(marRows.map(r=>r.date))].sort();
    const tracesM=[];
    for(const [wh, arr] of Object.entries(byWhM)){
      const gp=Object.fromEntries(arr.map(r=>[r.date,r.gross_profit]));
      const mp=Object.fromEntries(arr.map(r=>[r.date,r.margin_pct]));
      tracesM.push({x:datesM,y:datesM.map(d=>gp[d]??0),type:'bar',name:wh+' GP',opacity:0.75});
      tracesM.push({x:datesM,y:datesM.map(d=>mp[d]??0),type:'scatter',mode:'lines',name:wh+' %',yaxis:'y2'});
    }
    Plotly.newPlot('chart-margin', tracesM, {
      paper_bgcolor:'#0b0c10',plot_bgcolor:'#0b0c10',xaxis:{gridcolor:'#222831',tickformat:'%Y-%m-%d'},
      yaxis:{gridcolor:'#222831',title:'Валовая прибыль ₽'},
      yaxis2:{gridcolor:'#222831',title:'Маржа %',overlaying:'y',side:'right'},
      barmode:'group',margin:{t:10,r:60,b:40,l:60}
    }, {displayModeBar:false,responsive:true});

    const byWhI = by(infRows,'warehouse'); const datesI=[...new Set(infRows.map(r=>r.date))].sort();
    Plotly.newPlot('chart-inflow',
      Object.entries(byWhI).map(([wh, arr])=>{
        const map=Object.fromEntries(arr.map(r=>[r.date,r.inflow]));
        return {x:datesI,y:datesI.map(d=>map[d]??0),type:'bar',name:wh};
      }),
      {paper_bgcolor:'#0b0c10',plot_bgcolor:'#0b0c10',xaxis:{gridcolor:'#222831',tickformat:'%Y-%m-%d'},yaxis:{gridcolor:'#222831',title:'Оприходования ₽'},barmode:'group',margin:{t:10,r:10,b:40,l:60}},
      {displayModeBar:false,responsive:true}
    );
  }
}

// ---- SUMMARY helpers (multi-warehouse) ----
async function fetchSummary(start,end,group,whId){ // one warehouse
  const url=new URL('/api/summary',location.origin);
  url.searchParams.set('start',start); url.searchParams.set('end',end); url.searchParams.set('group',group||'day');
  if(whId) url.searchParams.set('warehouse_id',whId);
  return jget(url.toString());
}
function sumTotals(a,b){ // sums totals-like objects
  const out={}; for(const k of ['revenue','cost','discount','returns_cost','inflow_cost','receipts']){
    out[k]=(a?.[k]||0)+(b?.[k]||0);
  } return out;
}
function sumSeries(a,b){

  // Склеиваем по ключу period и суммируем все основные поля, если они есть
  const map=new Map();
  const take = (obj, k) => {
    if(!obj) return 0;
    const v = obj[k];
    return Number.isFinite(+v) ? (+v) : 0;
  };
  const KEYS = ['revenue','cost','discount','returns_cost','inflow_cost','receipts'];
  for(const r of (a||[])){
    const row = { period: r.period };
    for(const k of KEYS) row[k] = take(r,k);
    map.set(r.period, row);
  }
  for(const r of (b||[])){
    const m = map.get(r.period) || { period:r.period };
    for(const k of KEYS) m[k] = (m[k]||0) + take(r,k);
    map.set(r.period, m);
  }
  return [...map.values()].sort((x,y)=>x.period.localeCompare(y.period));
}
async function fetchSummaryTotalsMulti(start,end,group,whIds){
  if(!whIds || whIds.length===0) return fetchSummary(start,end,group,null);
  const arr=await Promise.all(whIds.map(id=>fetchSummary(start,end,group,id)));
  // reduce totals + compare
  const base = {totals:{}, compare:{previous:{}, previous_year:{}}};
  const out = arr.reduce((acc,cur)=>{
    acc.totals = sumTotals(acc.totals, cur.totals);
    acc.compare = {
      previous: sumTotals(acc.compare.previous, cur.compare?.previous),
      previous_year: sumTotals(acc.compare.previous_year, cur.compare?.previous_year),
    };
    // series суммировать для сравнительного графика
    acc.series = sumSeries(acc.series, cur.series);
    return acc;
  }, {...base, series:[]});
  return out;
}
async function fetchSummarySeriesMulti(start,end,group,whIds){

  const data=await fetchSummaryTotalsMulti(start,end,group,whIds);
  const src = data.series||[];
  return src.map(r=>({
    period: r.period,
    revenue: r.revenue||0,
    cost: r.cost||0,
    discount: r.discount||0,
    returns_cost: r.returns_cost||0,
    inflow_cost: r.inflow_cost||0,
    receipts: r.receipts||0
  }));
}

// ---- writeoff sums (multi) from /api/writeoff/reasons ----
function isDefect(reason){
  if(!reason) return false;
  const s=String(reason).toLowerCase();
  return s.includes('брак');
}
function isInventory(reason){
  if(!reason) return false;
  const s=String(reason).toLowerCase();
  return s.includes('инвент') || s.includes('интвент') || s.includes('инвентар');
}
function sumWriteoffByBucket(rows, whIds, bucket){ // bucket: 'defect'|'inventory'
  const idsSet=new Set((whIds||[]).map(String));
  let sum=0;
  for(const r of rows){
    if(idsSet.size && !idsSet.has(String(r.warehouse_id))) continue;
    const reason=r.reason||'';
    if(bucket==='defect' && isDefect(reason)) sum+= (r.cost||0);
    else if(bucket==='inventory' && isInventory(reason)) sum+= (r.cost||0);
  }
  return sum;
}

// === Универсальный сравнительный график: выбор метрик ===
function ensureCompareMetricToggles(){
  const chart = document.getElementById('chart-compare');
  if(!chart) return; // график ещё не в DOM
  if(document.getElementById('compare-metric-toggles')) return;

  // Родительская карточка, если есть
  const card = chart.closest('.card');
  const box  = document.createElement('div');
  box.id = 'compare-metric-toggles';
  box.className = 'muted';
  box.style.cssText = 'margin:8px 0 6px 0; display:flex; gap:12px; flex-wrap:wrap;';
  box.innerHTML = `
    <span>Метрики графика:</span>
    <label><input type="checkbox" name="cmp-metric" value="revenue" checked> Выручка</label>
    <label><input type="checkbox" name="cmp-metric" value="gross_profit"> Валовая прибыль</label>
    <label><input type="checkbox" name="cmp-metric" value="margin_pct"> Маржа %</label>
    <label><input type="checkbox" name="cmp-metric" value="avg_check"> Средний чек</label>
    <label><input type="checkbox" name="cmp-metric" value="checks_count"> Кол-во чеков</label>
    <label><input type="checkbox" name="cmp-metric" value="inflow"> Оприходования</label>
    <label><input type="checkbox" name="cmp-metric" value="defect"> Брак</label>
    <label><input type="checkbox" name="cmp-metric" value="inventory"> Инвентаризация</label>
  `;

  // Вставляем ПЕРЕД графиком: если есть .card, то прямо перед chart внутри карточки, иначе в его родителя
  const parent = chart.parentNode;
  parent.insertBefore(box, chart);

  // Временная подсказка, чтобы глазами увидеть, что блок появился
  try{
    const tip = document.createElement('div');
    tip.textContent = '✅ Метрики графика готовы';
    tip.style.cssText = 'font-size:12px;color:#7dd3fc;margin-top:4px;';
    box.appendChild(tip);
    setTimeout(()=>{ tip.remove(); }, 8000);
  }catch(_){}

  box.addEventListener('change', ()=>{ loadCompareChart(); });
}

function getSelectedCompareMetrics(){
  const boxes = document.querySelectorAll('#compare-metric-toggles input[name="cmp-metric"]:checked');
  const list = [...boxes].map(b=>b.value);
  return list.length ? list : ['revenue'];
}
// writeoff helpers for compare series
async function fetchWriteoffDailyMap(start, end, whIds){
  const url=new URL('/api/writeoff/daily',location.origin);
  url.searchParams.set('start',start); url.searchParams.set('end',end);
  const data=(await jget(url.toString())).data||[];
  const ids = new Set((whIds||[]).map(String));
  const f = data.filter(r=> ids.size===0 || ids.has(String(r.warehouse_id)));
  const days=[...new Set(f.map(r=>r.date))].sort();
  const m=Object.fromEntries(days.map(d=>[d,{defect:0,inventory:0,total:0}]));
  for(const r of f){
    const d=r.date;
    m[d].defect += r.defect||0;
    m[d].inventory += r.inventory||0;
    m[d].total += r.total||0;
  }
  return m; // { 'YYYY-MM-DD': {defect, inventory, total} }
}

async function loadCompareChart(){

  ensureCompareMetricToggles();

  const start=document.getElementById('start')?.value;
  const end=document.getElementById('end')?.value;
  const group=document.getElementById('group')?.value || 'day';
  const whIds=getSelectedWarehouseIds();
  const metrics = getSelectedCompareMetrics();

  // базовые серии из /api/summary (revenue/cost/discount/returns_cost/inflow_cost/receipts)
  const nowSeries=await fetchSummarySeriesMulti(start,end,group,whIds);
  const xNow=nowSeries.map(r=>r.period);

  // Периоды сравнения
  const doPrev=document.getElementById('cmp-prev-period')?.checked;
  const doYoY=document.getElementById('cmp-prev-year')?.checked;
  const pp=prevPeriodRange(start,end);
  const yy=prevYearRange(start,end);

  const prevSeries = doPrev ? await fetchSummarySeriesMulti(pp.start,pp.end,group,whIds) : [];
  const yoySeries  = doYoY ? await fetchSummarySeriesMulti(yy.start,yy.end,group,whIds) : [];

  // Доп. данные для брака/инвентаризации
  let woNow={}, woPrev={}, woYoy={};
  if(metrics.includes('defect') || metrics.includes('inventory')){
    woNow  = await fetchWriteoffDailyMap(start,end,whIds);
    if(doPrev) woPrev = await fetchWriteoffDailyMap(pp.start,pp.end,whIds);
    if(doYoY)  woYoy  = await fetchWriteoffDailyMap(yy.start,yy.end,whIds);
  }

  // Метрики
  const access = {
    revenue: (r)=> r.revenue||0,
    gross_profit: (r)=> (r.revenue||0) - (r.cost||0),
    margin_pct: (r)=> (r.revenue ? (( (r.revenue - (r.cost||0) - (r.discount||0) - (r.returns_cost||0)) / r.revenue) * 100) : 0),
    avg_check: (r)=> (r.receipts ? (r.revenue / r.receipts) : 0),
    checks_count: (r)=> r.receipts||0,
    inflow: (r)=> r.inflow_cost||0
  };
  function accessWriteoff(day, kind, map){ // kind: defect|inventory
    const row = map[day]; if(!row) return 0;
    return (kind==='defect'? row.defect : row.inventory) || 0;
  }
  const units = {
    revenue: '₽', gross_profit: '₽', margin_pct: '%', avg_check: '₽', checks_count: 'шт', inflow: '₽',
    defect: '₽', inventory: '₽'
  };
  const names = {
    revenue: 'Выручка', gross_profit: 'Валовая прибыль', margin_pct: 'Маржа %',
    avg_check: 'Средний чек', checks_count: 'Кол-во чеков', inflow: 'Оприходования',
    defect: 'Брак', inventory: 'Инвентаризация'
  };

  const traces=[];

  const pushMetric = (key, seriesNow, seriesPrev, seriesYoy)=>{
    traces.push({x:xNow, y:xNow.map((d,i)=>{
      if(key==='defect'||key==='inventory') return accessWriteoff(d, key, woNow);
      const r = seriesNow[i]||{};
      return (access[key]||(()=>0))(r);
    }), type:'scatter', mode:'lines+markers', name: names[key]+' (текущий)' });

    if(doPrev){
      const yPrev = xNow.map((d,i)=>{
        if(key==='defect'||key==='inventory') return accessWriteoff(d, key, woPrev);
        const r = seriesPrev[i]||{};
        return (access[key]||(()=>0))(r);
      });
      traces.push({x:xNow, y:yPrev, type:'scatter', mode:'lines', name:names[key]+' (пред.)', line:{dash:'dot'}});
    }

    if(doYoY){
      const yYoy = xNow.map((d,i)=>{
        if(key==='defect'||key==='inventory') return accessWriteoff(d, key, woYoy);
        const r = seriesYoy[i]||{};
        return (access[key]||(()=>0))(r);
      });
      traces.push({x:xNow, y:yYoy, type:'scatter', mode:'lines', name:names[key]+' (год назад)', line:{dash:'dash'}});
    }
  };

  // Выравниваем prev/yoy длиной под текущий период
  const pad = (arr)=>{ const a=(arr||[]).slice(0,xNow.length); while(a.length<xNow.length) a.push({}); return a; };
  const prevPad = pad(prevSeries);
  const yoyPad  = pad(yoySeries);

  for(const key of metrics){
    pushMetric(key, nowSeries, prevPad, yoyPad);
  }

  if(window.Plotly){
    const yTitle = metrics.length===1 ? (names[metrics[0]] + ' ' + (units[metrics[0]]||'')) : 'Значение';
    Plotly.newPlot('chart-compare', traces, {
      paper_bgcolor:'#0b0c10', plot_bgcolor:'#0b0c10',
      xaxis:{gridcolor:'#222831', title:(group==='day'?'Дни':'Периоды')},
      yaxis:{gridcolor:'#222831', title:yTitle},
      margin:{t:10,r:10,b:40,l:60}, legend:{orientation:'h'}
    }, {displayModeBar:false, responsive:true});
  }
}

async function loadTopWarehouses(start,end){
  try{
    const res=await jget(`/api/top/warehouses?start=${start}&end=${end}`);
    const rows=res.data||[];
    const el=document.getElementById('top-warehouses'); if(!el) return;
    let html='<table><thead><tr><th>Склад</th><th>Выручка</th><th>GP</th><th>Маржа</th><th>Чеки</th><th>Ср. чек</th></tr></thead><tbody>';
    for(const r of rows){ html+=`<tr><td>${r.warehouse}</td><td>${fmt(r.revenue)} ₽</td><td>${fmt(r.gross_profit)} ₽</td><td>${(r.margin_pct||0).toFixed(1)} %</td><td>${(r.checks||0).toFixed(0)}</td><td>${fmt(r.avg_ticket||0)} ₽</td></tr>`; }
    html+='</tbody></table>'; el.innerHTML=html;
  }catch(e){ console.warn('top warehouses failed', e); }
}
async function loadTopProducts(start,end,wh){
  try{
    // если выбран НЕ один склад — показываем по всем (API односекционный)
    const selected=getSelectedWarehouseIds();
    const whId = (selected.length===1) ? selected[0] : '';
    const url=new URL('/api/top/products',location.origin);
    url.searchParams.set('start',start); url.searchParams.set('end',end); if(whId) url.searchParams.set('warehouse_id',whId);
    const res=await jget(url.toString()); const rows=res.data||[];
    const el=document.getElementById('top-products'); if(!el) return;
    let html='<table><thead><tr><th>Товар</th><th>Выручка</th><th>GP</th><th>Маржа</th><th>Кол-во</th><th>Ср. цена</th></tr></thead><tbody>';
    for(const r of rows){ html+=`<tr><td>${r.name}</td><td>${fmt(r.revenue)} ₽</td><td>${fmt(r.gross_profit)} ₽</td><td>${(r.margin_pct||0).toFixed(1)} %</td><td>${(r.qty||0).toFixed(0)}</td><td>${fmt(r.avg_price||0)} ₽</td></tr>`; }
    html+='</tbody></table>'; el.innerHTML=html;
    const scope=document.getElementById('tp-scope'); if(scope) scope.textContent=(whId?('склад ID '+whId): (selected.length>1?'по выбранным складам':'по всем складам'));
  }catch(e){ console.warn('top products failed', e); }
}

// reasons table (current period)
function ensureWriteoffContainers(){
  const grid=document.querySelector('.grid'); if(!grid) return;
  if(!document.getElementById('chart-writeoff')){
    const card=document.createElement('div');
    card.className='card col-12';
    card.innerHTML='<div class="muted">Списания по дням (дефект/инвентаризация/прочее) — стэк + линия Total</div><div id="chart-writeoff" style="height:380px"></div>';
    grid.appendChild(card);
  }
  if(!document.getElementById('writeoff-reasons')){
    const card=document.createElement('div');
    card.className='card col-12';
    card.innerHTML='<div class="muted">Списания по причинам (сумма и % от выручки за период)</div><div id="writeoff-reasons"></div>';
    grid.appendChild(card);
  }
}

async function loadWriteoffBlock(){
  ensureWriteoffContainers();
  const start=document.getElementById('start')?.value;
  const end=document.getElementById('end')?.value;
  const selectedWhIds=getSelectedWarehouseIds();
  const selectedSet=new Set(selectedWhIds.map(String));

  // daily
  const dailyURL=new URL('/api/writeoff/daily',location.origin);
  dailyURL.searchParams.set('start',start); dailyURL.searchParams.set('end',end);
  const daily=(await jget(dailyURL.toString())).data||[];
  const dailyFiltered = daily.filter(r=> selectedSet.has(String(r.warehouse_id)));
  const days=[...new Set(dailyFiltered.map(r=>r.date))].sort();
  const mapByDate=Object.fromEntries(days.map(d=>[d,{defect:0,inventory:0,other:0,total:0}]));
  for(const r of dailyFiltered){
    const m=mapByDate[r.date];
    m.defect+=r.defect||0; m.inventory+=r.inventory||0; m.other+=r.other||0; m.total+=r.total||0;
  }
  if(window.Plotly){
    const x=days, yDef=x.map(d=>mapByDate[d].defect), yInv=x.map(d=>mapByDate[d].inventory), yOth=x.map(d=>mapByDate[d].other), yTot=x.map(d=>mapByDate[d].total);
    Plotly.newPlot('chart-writeoff',[
      {x,y:yDef,type:'bar',name:'Дефект'},
      {x,y:yInv,type:'bar',name:'Инвентаризация'},
      {x,y:yOth,type:'bar',name:'Прочее'},
      {x,y:yTot,type:'scatter',mode:'lines+markers',name:'Всего',yaxis:'y2'}
    ],{
      paper_bgcolor:'#0b0c10',plot_bgcolor:'#0b0c10',
      xaxis:{gridcolor:'#222831',tickformat:'%Y-%m-%d'},
      yaxis:{gridcolor:'#222831',title:'Списания ₽',rangemode:'tozero'},
      yaxis2:{gridcolor:'#222831',title:'Всего ₽',overlaying:'y',side:'right'},
      barmode:'stack',margin:{t:10,r:60,b:40,l:60}
    },{displayModeBar:false,responsive:true});
  }

  // reasons -> table
  const reasonURL=new URL('/api/writeoff/reasons',location.origin);
  reasonURL.searchParams.set('start',start); reasonURL.searchParams.set('end',end);
  const reasonRows=(await jget(reasonURL.toString())).data||[];
  const reasonFiltered=reasonRows.filter(r=> selectedSet.has(String(r.warehouse_id)));
  const totalInPeriod=reasonFiltered.reduce((s,r)=>s+(r.cost||0),0);

  let revenueTotal=0;
  try{
    const sum=await fetchSummaryTotalsMulti(start,end,'day',selectedWhIds);
    revenueTotal=sum?.totals?.revenue||0;
  }catch(_) {}

  const aggr={};
  for(const r of reasonFiltered){ const k=r.reason||'(без причины)'; aggr[k]=(aggr[k]||0)+(r.cost||0); }
  const rows=Object.entries(aggr).sort((a,b)=>b[1]-a[1]).map(([reason,cost])=>{
    const pctW = totalInPeriod? (cost/totalInPeriod*100):0;
    const pctR = revenueTotal? (cost/revenueTotal*100):0;
    return {reason, cost, pctW, pctR};
  });

  let html='<table><thead><tr><th>Причина</th><th>Сумма ₽</th><th>% в списаниях</th><th>% от выручки</th></tr></thead><tbody>';
  for(const r of rows){ html+=`<tr><td>${r.reason}</td><td>${fmt(r.cost)}</td><td>${r.pctW.toFixed(1)} %</td><td>${r.pctR.toFixed(2)} %</td></tr>`; }
  if(rows.length===0) html+='<tr><td colspan="4" class="muted">Нет данных</td></tr>';
  html+='</tbody></table>';
  const box=document.getElementById('writeoff-reasons'); if(box) box.innerHTML=html;
}

async function loadComparison(){
  const start=document.getElementById('start')?.value;
  const end=document.getElementById('end')?.value;
  const group=document.getElementById('group')?.value || 'day';
  const whIds=getSelectedWarehouseIds();

  // суммарная summary по выбранным складам
  const data=await fetchSummaryTotalsMulti(start,end,group,whIds);
  const t=data.totals||{}; const p=(data.compare||{}).previous||{}; const y=(data.compare||{}).previous_year||{};
  const pack=(r)=>({ rev:r.revenue||0, gp:(r.revenue||0)-(r.cost||0), mar:(r.revenue?(((r.revenue-(r.cost||0))/r.revenue*100)):0), at:(r.receipts?(r.revenue/r.receipts):0), chk:(r.receipts||0), inflow:r.inflow_cost||0 });
  const cur=pack(t), prev=pack(p), yoy=pack(y);

  // для writeoff строк метрики — считаем по причинам на текущий, пред. период и год назад
  const pp=prevPeriodRange(start,end), yy=prevYearRange(start,end);
  const [re_cur, re_prev, re_yoy] = await Promise.all([
    jget(`/api/writeoff/reasons?start=${start}&end=${end}`),
    jget(`/api/writeoff/reasons?start=${pp.start}&end=${pp.end}`),
    jget(`/api/writeoff/reasons?start=${yy.start}&end=${yy.end}`),
  ]);
  const rows_cur = re_cur.data||[], rows_prev=re_prev.data||[], rows_yoy=re_yoy.data||[];
  const def_cur = sumWriteoffByBucket(rows_cur, whIds, 'defect');
  const def_prev= sumWriteoffByBucket(rows_prev, whIds, 'defect');
  const def_yoy = sumWriteoffByBucket(rows_yoy, whIds, 'defect');
  const inv_cur = sumWriteoffByBucket(rows_cur, whIds, 'inventory');
  const inv_prev= sumWriteoffByBucket(rows_prev, whIds, 'inventory');
  const inv_yoy = sumWriteoffByBucket(rows_yoy, whIds, 'inventory');

  // динамические подписи лет
  const endY = parseISO(end).getFullYear();
  const prevEndY = parseISO(start).getFullYear();
  const yoyY = endY-1;

  document.getElementById('compare').textContent=`Период ${start} – ${end} • Склад(ы): ${getSelectedWarehouseIds().length||'все'} • Группировка: ${group}`;

  const rows=[
    ['Выручка',cur.rev,prev.rev,pctDelta(cur.rev,prev.rev),yoy.rev,pctDelta(cur.rev,yoy.rev)],
    ['Валовая прибыль',cur.gp,prev.gp,pctDelta(cur.gp,prev.gp),yoy.gp,pctDelta(cur.gp,yoy.gp)],
    ['Маржа %',cur.mar,prev.mar,cur.mar-prev.mar,yoy.mar,cur.mar-yoy.mar],
    ['Средний чек',cur.at,prev.at,pctDelta(cur.at,prev.at),yoy.at,pctDelta(cur.at,yoy.at)],
    ['Количество чеков',cur.chk,prev.chk,pctDelta(cur.chk,prev.chk),yoy.chk,pctDelta(cur.chk,yoy.chk)],
    // Новые строки:
    ['Оприходования',cur.inflow,prev.inflow,pctDelta(cur.inflow,prev.inflow),yoy.inflow,pctDelta(cur.inflow,yoy.inflow)],
    ['Брак',def_cur,def_prev,pctDelta(def_cur,def_prev),def_yoy,pctDelta(def_cur,def_yoy)],
    ['Брак % от выручки',cur.rev?def_cur/cur.rev*100:0, prev.rev?def_prev/prev.rev*100:0, (cur.rev?def_cur/cur.rev*100:0)-(prev.rev?def_prev/prev.rev*100:0), yoy.rev?def_yoy/yoy.rev*100:0, (cur.rev?def_cur/cur.rev*100:0)-(yoy.rev?def_yoy/yoy.rev*100:0)],
    ['Инвентаризация',inv_cur,inv_prev,pctDelta(inv_cur,inv_prev),inv_yoy,pctDelta(inv_cur,inv_yoy)],
    ['Инвентаризация % от выручки',cur.rev?inv_cur/cur.rev*100:0, prev.rev?inv_prev/prev.rev*100:0, (cur.rev?inv_cur/cur.rev*100:0)-(prev.rev?inv_prev/prev.rev*100:0), yoy.rev?inv_yoy/yoy.rev*100:0, (cur.rev?inv_cur/cur.rev*100:0)-(yoy.rev?inv_yoy/yoy.rev*100:0)],
  ];

  let html=`<table><thead><tr>
  <th>Метрика</th>
  <th>Текущий (${endY})</th>
  <th>Предыдущий (${prevEndY})</th>
  <th>Δ к пред.</th>
  <th>Год назад (${yoyY})</th>
  <th>Δ к прошл. году</th>
  </tr></thead><tbody>`;

  for(const r of rows){
    const [name,curv,pv,d1,yv,d2]=r;
    const isPctRow = name.includes('%');
    const curFmt = isPctRow ? (curv||0).toFixed(2)+' %'
                  : name==='Маржа %'? (curv||0).toFixed(1)+' %'
                  : (name==='Количество чеков'? (curv||0).toFixed(0) : fmt(curv||0)+' ₽');
    const pFmt   = isPctRow ? (pv||0).toFixed(2)+' %'
                  : name==='Маржа %'? (pv||0).toFixed(1)+' %'
                  : (name==='Количество чеков'? (pv||0).toFixed(0) : fmt(pv||0)+' ₽');
    const yFmt   = isPctRow ? (yv||0).toFixed(2)+' %'
                  : name==='Маржа %'? (yv||0).toFixed(1)+' %'
                  : (name==='Количество чеков'? (yv||0).toFixed(0) : fmt(yv||0)+' ₽');
    const d1Fmt  = isPctRow ? (isFinite(d1)? d1.toFixed(2)+' п.п.':'—')
                  : name==='Маржа %'? (isFinite(d1)? d1.toFixed(1)+' п.п.':'—')
                  : (isFinite(d1)? d1.toFixed(1)+' %':'—');
    const d2Fmt  = isPctRow ? (isFinite(d2)? d2.toFixed(2)+' п.п.':'—')
                  : name==='Маржа %'? (isFinite(d2)? d2.toFixed(1)+' п.п.':'—')
                  : (isFinite(d2)? d2.toFixed(1)+' %':'—');
    html+=`<tr><td>${name}</td><td>${curFmt}</td><td>${pFmt}</td><td class="${cls(d1)}">${d1Fmt}</td><td>${yFmt}</td><td class="${cls(d2)}">${d2Fmt}</td></tr>`;
  }
  html+='</tbody></table>';
  document.getElementById('compare-table').innerHTML=html;

  // ТОПы
  await Promise.all([loadTopWarehouses(start,end), loadTopProducts(start,end)]);
  // Сравнительный график
  await loadCompareChart();
  // Списания (график и причины)
  await loadWriteoffBlock();
}

function addChartToggles(){
  try{
    const grid=document.querySelector('.grid'); if(!grid) return;
    if(document.getElementById('chart-toggles')) return;
    const card=document.createElement('div');
    card.className='card col-12';
    card.id='chart-toggles';
    card.innerHTML = `
      <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <span class="muted">Показать графики:</span>
        <label><input type="checkbox" data-target="#chart-revenue" checked> Выручка</label>
        <label><input type="checkbox" data-target="#chart-margin" checked> Маржа/GP</label>
        <label><input type="checkbox" data-target="#chart-inflow" checked> Оприходования</label>
        <label><input type="checkbox" data-target="#chart-writeoff" checked> Списания</label>
      </div>`;
    grid.insertBefore(card, grid.firstChild);
    card.querySelectorAll('input[type=checkbox]').forEach(cb=>{
      cb.addEventListener('change',(e)=>{
        const sel=e.target.getAttribute('data-target');
        const el=document.querySelector(sel)?.closest('.card') || document.querySelector(sel);
        if(el) el.style.display=e.target.checked?'':'none';
      });
    });
  }catch(e){ console.debug('toggles failed', e); }
}

const loadComparisonDebounced = debounced(()=>loadComparison(), 250);

function wireQuickButtons(){
  const qs=(id)=>document.getElementById(id);
  qs('btn-cur-month')?.addEventListener('click', ()=>{ setPeriodCurrentMonth(); loadComparisonDebounced(); });
  qs('btn-prev-month')?.addEventListener('click', ()=>{ setPeriodPrevMonth(); loadComparisonDebounced(); });
  qs('btn-ytd')?.addEventListener('click', ()=>{ setPeriodYTD(); loadComparisonDebounced(); });
  qs('btn-prev-year')?.addEventListener('click', ()=>{ setPeriodPrevYear(); loadComparisonDebounced(); });
  qs('cmp-prev-period')?.addEventListener('change', loadCompareChart);
  qs('cmp-prev-year')?.addEventListener('change', loadCompareChart);
  qs('group')?.addEventListener('change', loadCompareChart);
  qs('apply')?.addEventListener('click', loadComparisonDebounced);
}

async function boot(){
  try{
    setPeriodCurrentMonth();
    await loadWarehouses();
    await loadChartsAndKPI();
    ensureCompareMetricToggles();
    wireQuickButtons();
    addChartToggles();
    await loadComparison();
    try{ ensureCompareMetricToggles(); }catch(e){}
  }catch(e){ console.error('dashboard boot failed', e); }
}
document.addEventListener('DOMContentLoaded', boot);

// === [WA] compare-toggles injector v1 ===
(function(){
  try {
    console.log('[WA] compare-toggles injector alive');

    function insertToggles() {
      const chart = document.getElementById('chart-compare');
      if (!chart) return false;
      if (document.getElementById('compare-metric-toggles')) return true;

      const box = document.createElement('div');
      box.id = 'compare-metric-toggles';
      box.className = 'muted';
      box.style.cssText = 'margin:8px 0 6px 0; display:flex; gap:12px; flex-wrap:wrap;';
      box.innerHTML = `
        <span>Метрики графика:</span>
        <label><input type="checkbox" name="cmp-metric" value="revenue" checked> Выручка</label>
        <label><input type="checkbox" name="cmp-metric" value="gross_profit"> Валовая прибыль</label>
        <label><input type="checkbox" name="cmp-metric" value="margin_pct"> Маржа %</label>
        <label><input type="checkbox" name="cmp-metric" value="avg_check"> Средний чек</label>
        <label><input type="checkbox" name="cmp-metric" value="checks_count"> Кол-во чеков</label>
        <label><input type="checkbox" name="cmp-metric" value="inflow"> Оприходования</label>
        <label><input type="checkbox" name="cmp-metric" value="defect"> Брак</label>
        <label><input type="checkbox" name="cmp-metric" value="inventory"> Инвентаризация</label>
      `;
      // Вставляем ПЕРЕД графиком
      chart.parentNode.insertBefore(box, chart);
      box.addEventListener('change', function(){
        if (typeof loadCompareChart === 'function') {
          try { loadCompareChart(); } catch(e){ console.warn('loadCompareChart failed', e); }
        }
      });

      // маленькая подсказка, чтобы глазами увидеть, что патч активен
      const tip = document.createElement('div');
      tip.textContent = '✅ Метрики графика готовы';
      tip.style.cssText = 'font-size:12px;color:#7dd3fc;margin-top:4px;';
      box.appendChild(tip);
      setTimeout(()=>{ try{ tip.remove(); }catch(_){ } }, 6000);

      return true;
    }

    // Пробуем сразу и по готовности DOM
    document.addEventListener('DOMContentLoaded', insertToggles);
    setTimeout(insertToggles, 500);
    setTimeout(insertToggles, 1500);

    // Следим за изменениями DOM, чтобы не потерять блок при перерисовках
    const mo = new MutationObserver(() => { insertToggles(); });
    mo.observe(document.documentElement, { subtree:true, childList:true });
  } catch(e) {
    console.error('[WA] injector error', e);
  }
})();
/// === end injector ===

// === [WA] persist compare metric toggles ===
(function(){
  try{
    const KEY='wa_cmp_metrics';
    function restore(){
      const box = document.getElementById('compare-metric-toggles');
      if(!box) return;
      // восстановим сохранённый набор метрик
      let saved=[];
      try{ saved = JSON.parse(localStorage.getItem(KEY)||'[]') || []; }catch(_){}
      if(saved.length){
        box.querySelectorAll('input[name="cmp-metric"]').forEach(i=>{
          i.checked = saved.includes(i.value);
        });
        if(typeof loadCompareChart==='function'){
          try{ loadCompareChart(); }catch(_){}
        }
      }
      // сохраняем при каждом изменении
      box.addEventListener('change', ()=>{
        const sel=[...box.querySelectorAll('input[name="cmp-metric"]:checked')].map(i=>i.value);
        try{ localStorage.setItem(KEY, JSON.stringify(sel)); }catch(_){}
      }, {once:false});
    }
    document.addEventListener('DOMContentLoaded', ()=>setTimeout(restore, 150));
    setTimeout(restore, 800);
  }catch(e){ console.warn('[WA] persist error', e); }
})();
// === end persist ===

// === [WA] dual-axis for percent metrics on compare chart ===
(function(){
  function wrapOnce(){
    if(typeof window.loadCompareChart !== 'function') return false;
    if(window.__wa_patched_compare__) return true;
    const orig = window.loadCompareChart;
    window.loadCompareChart = async function(){
      // рисуем как обычно
      await orig.apply(this, arguments);
      try{
        const el = document.getElementById('chart-compare');
        if(!el || !window.Plotly) return;

        const data = (el.data || []).map(tr => ({...tr}));
        const hasPct = data.some(tr => /Маржа\s*%/i.test(String(tr.name||'')));
        if(!hasPct) return; // нечего городить вторую ось

        // Переносим серии с «Маржа %» на ось y2
        for(const tr of data){
          if(/Маржа\s*%/i.test(String(tr.name||''))){
            tr.yaxis = 'y2';
            // Линии процентов оставляем как lines (без маркеров), если вдруг кто-то включил
            if(tr.type === 'scatter') tr.mode = 'lines';
          }
        }

        // Собираем новый layout на основе текущего
        const layout = JSON.parse(JSON.stringify(el.layout || {}));
        layout.yaxis = Object.assign({title:'Значение', gridcolor:'#222831'}, layout.yaxis||{});
        layout.yaxis2 = Object.assign({
          title: 'Проценты %',
          overlaying: 'y',
          side: 'right',
          gridcolor: layout.yaxis.gridcolor || '#222831'
        }, layout.yaxis2||{});

        // Перерисовываем обновлённой конфигурацией
        await Plotly.react(el, data, layout, {displayModeBar:false, responsive:true});
      }catch(e){
        console.debug('[WA] dual-axis patch skipped:', e);
      }
    };
    window.__wa_patched_compare__ = true;
    return true;
  }

  // Пытаемся обернуть сразу и потом ещё пару раз, вдруг дашборд ленивый
  if(!wrapOnce()){
    const t1 = setInterval(()=>{ if(wrapOnce()) clearInterval(t1); }, 200);
    setTimeout(()=> clearInterval(t1), 4000);
  }
})();
/// === end dual-axis ===
