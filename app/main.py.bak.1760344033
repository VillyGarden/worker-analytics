from fastapi import FastAPI, Request, Form, status, Depends, Query
from fastapi.responses import RedirectResponse, HTMLResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.sessions import SessionMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.exceptions import HTTPException as StarletteHTTPException
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from sqlalchemy.orm import Session
from sqlalchemy import select, func
from datetime import datetime, date, timedelta
import httpx

from .config import settings
from .db import get_session
from .models import Warehouse, SalesDaily
from .api import get_revenue_daily, get_margin_daily, get_inflow_daily, get_summary

def is_public(path: str) -> bool:
    if path.startswith('/health/db'): return True
    if path.startswith('/api/inflow/items'): return True
    return False

def _is_public_path(path: str) -> bool:
    # публичные эндпоинты, не требующие авторизации
    if path.startswith('/health/db'): return True
    if path.startswith('/openapi.json'): return True
    if path.startswith('/docs'): return True
    if path.startswith('/redoc'): return True
    if path.startswith('/api/inflow/items'): return True
    return False



app = FastAPI(title="Worker Analytics")
app.mount("/static", StaticFiles(directory=Path(__file__).parent / "static"), name="static")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

WHITELIST_EXACT = {"/login", "/health"}
WHITELIST_PREFIXES = ("/static", "/favicon.ico")

class AuthRequiredMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        path = (request.url.path or "/").rstrip("/") or "/"
        # public allowlist — пробрасываем без авторизации
        if path.startswith('/openapi.json') or path.startswith('/docs') or path.startswith('/redoc') \
           or path.startswith('/static') or path.startswith('/favicon.ico') \
           or path.startswith('/health') or path.startswith('/api/inflow/items'):
            return await call_next(request)
        try:
            user = request.session.get("user")
        except Exception as e:
            user = None
            print("AUTHDBG_ERR", {"err": str(e)})
            # public allowlist — пропускаем без авторизации эти пути
            try:
                _path = request.url.path
            except Exception:
                _path = str(getattr(getattr(request, "scope", {}), "get", lambda *_: "")("path"))
            if _path.startswith("/openapi.json") or _path.startswith("/docs") or _path.startswith("/redoc") or _path.startswith("/health/db") or _path.startswith("/api/inflow/items"):
                return await call_next(request)
            # >>> public allowlist — пропускаем без авторизации
            try:
                _path = request.url.path
            except Exception:
                _path = str(getattr(getattr(request,'scope',{}),'get',lambda *_: '')('path'))
            if _is_public_path(_path):
                return await call_next(request)
            # <<< end allowlist

        # компактный лог
        print("AUTHDBG", {"path": path, "user": user})

        WHITELIST_EXACT = {"/login", "/health"}
        WHITELIST_PREFIXES = ("/static", "/favicon.ico", "/openapi.json", "/docs", "/redoc")

        if path == "/login" and user:
            return RedirectResponse(url="/dashboard", status_code=status.HTTP_302_FOUND)

        if (not user) and not (path in WHITELIST_EXACT or any(path.startswith(pfx) for pfx in WHITELIST_PREFIXES)):
            return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)

        return await call_next(request)

# ВАЖНО: сначала SessionMiddleware, затем наш guard
app.add_middleware(AuthRequiredMiddleware)
app.add_middleware(SessionMiddleware, secret_key=settings.SECRET_KEY)

# ===== Аутентификация =====

@app.get("/login", response_class=HTMLResponse)
def login_form():
    return """
    <h2>Вход</h2>
    <form method="post" action="/login">
      <input type="text" name="username" placeholder="Логин"/><br/>
      <input type="password" name="password" placeholder="Пароль"/><br/>
      <button type="submit">Войти</button>
    </form>
    """

@app.post("/login")
def login(username: str = Form(...), password: str = Form(...), request: Request = None):
    if username == settings.ADMIN_USERNAME and password == settings.ADMIN_PASSWORD:
        request.session["user"] = username
        return RedirectResponse(url="/dashboard", status_code=302)
    return HTMLResponse("<p>Неверный логин или пароль</p><a href='/login'>Попробовать снова</a>", status_code=401)

@app.get("/")
def root(request: Request):
    if request.session.get("user"):
        return RedirectResponse(url="/dashboard", status_code=302)
    return RedirectResponse(url="/login", status_code=302)

@app.get("/logout")
def logout(request: Request):
    request.session.clear()
    return RedirectResponse(url="/login", status_code=302)

@app.get("/health")
def health():
    return {"status": "ok"}

# ===== API: существующие =====

@app.get("/api/revenue/daily")
def api_revenue_daily(days: int = Query(60, ge=1, le=365), session: Session = Depends(get_session)):
    try:
        data = get_revenue_daily(session, days=days)
        return {"data": data}
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

@app.get("/api/margin/daily")
def api_margin_daily(days: int = Query(60, ge=1, le=365), session: Session = Depends(get_session)):
    try:
        data = get_margin_daily(session, days=days)
        return {"data": data}
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

@app.get("/api/inflow/daily")
def api_inflow_daily(days: int = Query(60, ge=1, le=365), session: Session = Depends(get_session)):
    try:
        data = get_inflow_daily(session, days=days)
        return {"data": data}
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

@app.get("/api/warehouses")
def api_warehouses(session: Session = Depends(get_session)):
    rows = session.query(Warehouse.id, Warehouse.name).order_by(Warehouse.name.asc()).all()
    return {"data": [{"id": r.id, "name": r.name} for r in rows]}

@app.get("/api/summary")
def api_summary(
    request: Request,
    start: str,
    end: str,
    group: str = "day",
    warehouse_id: int | None = None,
    session: Session = Depends(get_session),
):
    try:
        start_d = datetime.strptime(start, "%Y-%m-%d").date()
        end_d = datetime.strptime(end, "%Y-%m-%d").date()
        data = get_summary(session, start=start_d, end=end_d, granularity=group, warehouse_id=warehouse_id)
        return data
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# ===== Новые API: ТОП складов (из БД) и ТОП товаров (из МоегоСклада) =====

@app.get("/api/top/warehouses")
def api_top_warehouses(
    start: str,
    end: str,
    limit: int = Query(5, ge=1, le=20),
    session: Session = Depends(get_session),
):
    s = datetime.strptime(start, "%Y-%m-%d").date()
    e = datetime.strptime(end, "%Y-%m-%d").date()
    stmt = (
        select(
            Warehouse.name.label("warehouse"),
            func.sum(SalesDaily.revenue).label("revenue"),
            func.sum(SalesDaily.cost).label("cost"),
            func.sum(SalesDaily.receipts_count).label("checks"),
        )
        .join(Warehouse, Warehouse.id == SalesDaily.warehouse_id)
        .where(SalesDaily.date >= s, SalesDaily.date <= e)
        .group_by(Warehouse.name)
        .order_by(func.sum(SalesDaily.revenue).desc())
        .limit(limit)
    )
    rows = session.execute(stmt).fetchall()
    out = []
    for r in rows:
        rev = float(r.revenue or 0)
        cost = float(r.cost or 0)
        gp = rev - cost
        out.append({
            "warehouse": r.warehouse,
            "revenue": rev,
            "gross_profit": gp,
            "margin_pct": (gp / rev * 100.0) if rev else 0.0,
            "checks": int(r.checks or 0),
            "avg_ticket": (rev / int(r.checks)) if int(r.checks or 0) else 0.0,
        })
    return {"data": out}

@app.get("/api/top/products")
def api_top_products(
    start: str,
    end: str,
    warehouse_id: int | None = None,
    limit: int = Query(10, ge=1, le=50),
    session: Session = Depends(get_session),
):
    # если указан склад, получаем его ms_id
    store_ms_id = None
    if warehouse_id:
        w = session.query(Warehouse).filter(Warehouse.id == warehouse_id).first()
        if not w:
            return JSONResponse(status_code=400, content={"error": "warehouse_id not found"})
        store_ms_id = w.ms_id

    MS_BASE = settings.MS_BASE_URL.rstrip("/")
    headers = {
        "Authorization": f"Bearer {settings.MS_API_TOKEN}",
        "Accept": "application/json;charset=utf-8",
        "Content-Type": "application/json",
        "User-Agent": "worker-analytics/top-products",
    }
    params = {
        "momentFrom": f"{start} 00:00:00",
        "momentTo": f"{end} 23:59:59",
        "limit": 1000,
    }
    if store_ms_id:
        params["filter"] = f"store={MS_BASE}/entity/store/{store_ms_id}"

    with httpx.Client(timeout=60.0, headers=headers) as c:
        r = c.get(f"{MS_BASE}/report/profit/byproduct", params=params)
        r.raise_for_status()
        data = r.json()

    agg = {}
    for row in (data.get("rows") or []):
        name = None
        code = None
        try:
            ass = row.get("assortment") or {}
            name = ass.get("name") or "Без названия"
            code = ass.get("code") or ""
        except Exception:
            name = "Без названия"
        key = f"{name} {('['+code+']') if code else ''}".strip()
        ssum = float(row.get("sellSum", 0) or 0) / 100.0
        scost = float(row.get("sellCostSum", 0) or 0) / 100.0
        qty = float(row.get("sellQuantity", 0) or 0)
        ret_cost = float(row.get("returnCostSum", 0) or 0) / 100.0
        price = float(row.get("sellPrice", 0) or 0) / 100.0
        disc = price * qty - ssum
        a = agg.setdefault(key, {"name": key, "revenue": 0.0, "cost": 0.0, "qty": 0.0, "discount": 0.0, "returns_cost": 0.0})
        a["revenue"] += ssum
        a["cost"] += scost
        a["qty"] += qty
        a["discount"] += disc
        a["returns_cost"] += ret_cost

    items = list(agg.values())
    items.sort(key=lambda x: x["revenue"], reverse=True)
    items = items[:limit]
    for it in items:
        it["gross_profit"] = it["revenue"] - it["cost"]
        it["margin_pct"] = (it["gross_profit"] / it["revenue"] * 100.0) if it["revenue"] else 0.0
        it["avg_price"] = (it["revenue"] / it["qty"]) if it["qty"] else 0.0

    return {"data": items}

# ===== Dashboard =====

@app.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    return '''
<!doctype html>
<html lang="ru"><head>
<meta charset="utf-8"/>
<title>Worker Analytics — Дашборд</title>
<script src="/static/plotly.min.js"></script>
<script src="/static/dashboard.js?v=9"></script>
<style>
 body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans";margin:24px;background:#0b0c10;color:#e6e6e6}
 h1{font-size:22px;margin:0 0 12px}
 .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
 .card{background:#14161b;border:1px solid #1f232b;border-radius:14px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.25)}
 .muted{color:#9aa0a6;font-size:13px}
 .kpi{font-size:26px;font-weight:700}
 .kpi-label{font-size:12px;color:#9aa0a6}
 .col-3{grid-column:span 3}
 .col-4{grid-column:span 4}
 .col-6{grid-column:span 6}
 .col-12{grid-column:span 12}
 .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:0 0 8px}
 input, select, button{background:#0f1116;color:#e6e6e6;border:1px solid #2a2f3a;border-radius:10px;padding:8px 10px}
 button{cursor:pointer}
 .good{color:#2ecc71} .bad{color:#ff6b6b}
 table{width:100%;border-collapse:collapse}
 th,td{padding:8px 10px;border-bottom:1px solid #242a34;text-align:right}
 th:first-child, td:first-child{text-align:left}
 .btn{padding:6px 10px;border-radius:10px;border:1px solid #2a2f3a;background:#0f1116}
 .btn:hover{filter:brightness(1.1)}
 .chip{font-size:12px;padding:2px 8px;border-radius:10px;background:#0f1116;border:1px solid #2a2f3a}
</style>
</head>
<body>
  <h1>Дашборд продаж</h1>

  <div class="card col-12">
    <div class="row" style="gap:14px">
      <label>Период:</label>
      <input type="date" id="start">
      <span>–</span>
      <input type="date" id="end">
      <label>Группировка:</label>
      <select id="group">
        <option value="day">День</option>
        <option value="month" selected>Месяц</option>
        <option value="year">Год</option>
      </select>
      <label>Склад:</label>
      <select id="warehouse"><option value="">Все</option></select>
      <button id="apply" class="btn">Применить</button>
      <span class="muted">Быстрые периоды:</span>
      <button class="btn" id="btn-cur-month">Текущий месяц</button>
      <button class="btn" id="btn-prev-month">Прошлый месяц</button>
      <button class="btn" id="btn-ytd">Год к дате</button>
      <button class="btn" id="btn-prev-year">Прошлый год</button>
    </div>
    <div class="row"><span id="compare" class="muted">Загрузите сравнение…</span></div>
    <div id="compare-table"></div>
  </div>

  
  <div class="card col-12">
    <div class="muted">Сравнительный график выручки (текущий период vs выбранные сравнения)</div>
    <div id="chart-compare" style="height:360px"></div>
    <div style="margin-top:8px" class="muted">
      <label><input type="checkbox" id="cmp-prev-period" checked> с предыдущим периодом</label>
      <label style="margin-left:12px"><input type="checkbox" id="cmp-prev-year"> с прошлым годом</label>
    </div>
  </div>
  <div class="grid">
    <div class="card col-3">
      <div class="kpi" id="kpi-rev">—</div>
      <div class="kpi-label">Выручка за 7 дней</div>
    </div>
    <div class="card col-3">
      <div class="kpi" id="kpi-gp">—</div>
      <div class="kpi-label">Валовая прибыль за 7 дней</div>
    </div>
    <div class="card col-3">
      <div class="kpi" id="kpi-margin">—</div>
      <div class="kpi-label">Средняя маржа за 7 дней</div>
    </div>
    <div class="card col-3">
      <div class="kpi" id="kpi-at">—</div>
      <div class="kpi-label">Средний чек за 7 дней</div>
    </div>

    <div class="card col-12">
      <div class="muted">Выручка по дням, разрез по складам (60 дней)</div>
      <div id="chart-revenue" style="height:360px"></div>
    </div>
    <div class="card col-12">
      <div class="muted">Валовая прибыль и маржа по дням, разрез по складам (60 дней)</div>
      <div id="chart-margin" style="height:400px"></div>
    </div>
    <div class="card col-12">
      <div class="muted">Оприходования по дням, разрез по складам (60 дней)</div>
      <div id="chart-inflow" style="height:340px"></div>
    </div>

    <div class="card col-6">
      <div class="muted">Топ складов за период</div>
      <div id="top-warehouses"></div>
    </div>
    <div class="card col-6">
      <div class="muted">Топ товаров за период <span id="tp-scope" class="chip">по всем складам</span></div>
      <div id="top-products"></div>
    </div>
  </div>
</body></html>
'''

@app.exception_handler(StarletteHTTPException)
def not_found_handler(request: Request, exc: StarletteHTTPException):
    if exc.status_code == 404:
        if request.session.get("user"):
            return RedirectResponse(url="/dashboard", status_code=302)
        return RedirectResponse(url="/login", status_code=302)
    return HTMLResponse(str(exc.detail), status_code=exc.status_code)

# ===== NEW: Writeoff APIs =====

@app.get("/api/writeoff/daily")
def api_writeoff_daily(
    start: str,
    end: str,
    warehouse_id: int | None = None,
    session: Session = Depends(get_session),
):
    """
    Агрегация списаний по дням из sales_daily:
      total / defect / inventory / other + проценты.
    """
    s = datetime.strptime(start, "%Y-%m-%d").date()
    e = datetime.strptime(end, "%Y-%m-%d").date()
    stmt = (
        select(
            SalesDaily.date.label("date"),
            Warehouse.name.label("warehouse"),
            func.sum(SalesDaily.writeoff_cost_total).label("total"),
            func.sum(SalesDaily.writeoff_cost_defect).label("defect"),
            func.sum(SalesDaily.writeoff_cost_inventory).label("inventory"),
            func.sum(SalesDaily.writeoff_cost_other).label("other"),
        )
        .join(Warehouse, Warehouse.id == SalesDaily.warehouse_id)
        .where(SalesDaily.date >= s, SalesDaily.date <= e)
        .group_by(SalesDaily.date, Warehouse.name)
        .order_by(SalesDaily.date.asc(), Warehouse.name.asc())
    )
    if warehouse_id:
        stmt = stmt.where(SalesDaily.warehouse_id == warehouse_id)

    rows = session.execute(stmt).fetchall()
    out = []
    for r in rows:
        total = float(r.total or 0)
        defect = float(r.defect or 0)
        inventory = float(r.inventory or 0)
        other = float(r.other or 0)
        out.append({
            "date": r.date.isoformat(),
            "warehouse": r.warehouse,
            "total": total,
            "defect": defect,
            "inventory": inventory,
            "other": other,
            "defect_pct": (defect/total*100.0) if total else 0.0,
            "inventory_pct": (inventory/total*100.0) if total else 0.0,
            "other_pct": (other/total*100.0) if total else 0.0,
        })
    return {"data": out}

@app.get("/api/writeoff/reasons")
def api_writeoff_reasons(
    start: str,
    end: str,
    warehouse_id: int | None = None,
    session: Session = Depends(get_session),
):
    """
    Разбивка списаний по причинам из writeoff_daily_reason (как в БД, без нормализации).
    """
    from sqlalchemy import text
    s = datetime.strptime(start, "%Y-%m-%d").date()
    e = datetime.strptime(end, "%Y-%m-%d").date()

    if warehouse_id:
        sql = text("""
          SELECT date, warehouse_id, reason, SUM(cost) AS cost
          FROM writeoff_daily_reason
          WHERE date BETWEEN :s AND :e AND warehouse_id = :wid
          GROUP BY date, warehouse_id, reason
          ORDER BY date ASC, warehouse_id ASC, reason ASC
        """)
        rows = session.execute(sql, {"s": s, "e": e, "wid": warehouse_id}).fetchall()
    else:
        sql = text("""
          SELECT date, warehouse_id, reason, SUM(cost) AS cost
          FROM writeoff_daily_reason
          WHERE date BETWEEN :s AND :e
          GROUP BY date, warehouse_id, reason
          ORDER BY date ASC, warehouse_id ASC, reason ASC
        """)
        rows = session.execute(sql, {"s": s, "e": e}).fetchall()

    wh_map = {w.id: w.name for w in session.query(Warehouse).all()}
    out = []
    for r in rows:
        out.append({
            "date": r.date.isoformat(),
            "warehouse_id": int(r.warehouse_id),
            "warehouse": wh_map.get(int(r.warehouse_id), f"id={r.warehouse_id}"),
            "reason": r.reason or "",
            "cost": float(r.cost or 0),
        })
    return {"data": out}

@app.get("/api/inflow/items")
def api_inflow_items(
    start: str = Query(..., description="YYYY-MM-DD"),
    end: str = Query(..., description="YYYY-MM-DD"),
    warehouse_id: str = Query(None, description="UUID склада"),
    limit: int = Query(500, ge=1, le=5000),
    session = Depends(get_session),
):
    # Позиции оприходований за период (и опционально по складу)
    q = (
        "SELECT i.date, i.warehouse_id, w.name AS warehouse, "
        "i.product_id, i.qty, i.price, i.cost, i.inventory_based "
        "FROM inflow_item_fact i "
        "JOIN warehouse w ON w.ms_id::uuid = i.warehouse_id
        "WHERE i.date BETWEEN :start AND :end "
        "{wh_filter} "
        "ORDER BY i.date DESC "
        "LIMIT :limit"
    )
    wh_filter = ""
    params = {"start": start, "end": end, "limit": limit}
    if warehouse_id:
        wh_filter = "AND i.warehouse_id::text = :wh"
        params["wh"] = warehouse_id
    q = q.format(wh_filter=wh_filter)
    rows = session.execute(text(q), params).mappings().all()
    return {"data": [dict(r) for r in rows]}
